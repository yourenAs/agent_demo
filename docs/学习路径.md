以下为 Markdown 版，并将关键名词统一使用代码格式（例如：`prompt`、`agent`、`MCP`、`Context Engine`、`RAG`、`LLM` 等），便于快速识别与检索。

# 一、整体地图：分层看 AI 应用
- 模型层（`LLM`）
  - 供应商与模型：`OpenAI`、`Anthropic`、`DeepSeek`、`Qwen`、`GLM`
  - 能力：`理解/生成`、`函数调用`（`tool/function calling`）、`长上下文`
- 会话与提示层（`Prompting`）
  - `prompt` 模板、`system prompt`、`few-shot`、`结构化输出`（`JSON`）
  - `上下文窗口` 与 `提示预算`（`token` 用在历史/知识/工具结果）
- 上下文层（`Context Engine`，语境编排器）
  - 负责把“该放给模型看的东西”准备好并塞进 `prompt`：`RAG` 的检索结果、`聊天历史`、`长期记忆`、`工具返回结果`、`压缩与排序`、`预算控制` 与 `缓存`
- 知识层（`RAG`，检索增强生成）
  - `文档采集/清洗/切分`、`嵌入`、`向量库`、`检索`、`重排`、`引用` 与 `去幻觉`
- 工具层（`Tools`）
  - `函数/工具调用`：`数据库`、`HTTP API`、`企业系统`
  - `MCP`（`Model Context Protocol`）：让模型“发现与调用”工具/数据源的标准协议
- 编排与智能体层（`Agent/Orchestration`）
  - 决策循环：`思考-计划-调用工具-观察-再计划-结束`
  - 框架：`LangGraph`/`LangChain`、`LlamaIndex`、`AutoGen`、`CrewAI`
  - 记忆：`短期（会话）` + `长期（RAG/事件日志）`
- 产品与运行层（`App`）
  - `API 服务` 与 `前端`、`鉴权`、`日志` 与 `可观测`、`评测` 与 `安全`、`成本` 与 `延迟优化`、`部署运维`

# 二、术语速通与依赖关系
- `Prompt（提示词）`
  - 模型的直接输入；质量直接决定输出上限
  - 依赖：对任务清晰认知；来自 `Context Engine` 的上下文
- `RAG（检索增强生成）`
  - 让模型“看见”外部知识，减少幻觉，易更新
  - 依赖：`嵌入模型`、`向量库`、`检索/重排`；被 `Context Engine` 调用
- `Agent（智能体）`
  - 一个带循环的“会做事”的 `LLM`：会思考、会选工具、会拆解子任务
  - 依赖：`工具/函数调用`、`Context Engine`、`规则/约束`；通常运行在 `编排框架` 中
- `MCP（Model Context Protocol）`
  - 暴露 `数据源/工具` 给模型的标准协议；模型可自发现工具能力与模式
  - 依赖：后端把企业系统/数据封装成 `MCP 服务器`；`Agent/模型` 通过 `MCP` 使用工具
- `Context Engine（上下文引擎）`
  - 一个逻辑层：判断该取什么信息（`RAG`? `工具`? `记忆`?），如何裁剪/压缩/排序后塞进 `prompt`
  - 依赖：`RAG`、`工具`、`会话历史`、`压缩与预算策略`、`缓存`
- `工具调用（Function/Tool Calling）`
  - `OpenAI`/`Anthropic`/`Qwen` 等均支持；定义 `JSON Schema`，模型按格式返回参数
  - 与 `MCP` 的关系：`MCP` 是“发现/对接更多工具”的通道；底层仍走 `工具调用`
- `记忆（Memory）`
  - `短期`：消息历史；`长期`：通过 `RAG` 或 `事件库` 检索
  - 依赖：`存储`、`检索`、`压缩策略`（防爆上下文）
- `评测与安全（Eval/Guardrails）`
  - `Prompt/检索质量评测`、`功能正确性测试`、`PII/越权拦截`、`结构化约束`
  - 依赖：`标注集`、`在线反馈`、`日志`

# 三、学习路径（4–6 周速成到可交付 `Demo`）
## 第 1 周：打基础（`LLM` 与 `Prompt`）
- 目标：能写出稳定的 `system prompt`；掌握 `结构化输出`
- 学：`系统/用户/工具提示`、`few-shot`、`JSON Schema 输出`、`思维链（CoT）/自一致`
- 练：写一个“文本润色 + 提取为 `JSON`”的脚本；加上`重试`与`超时`

## 第 2 周：`RAG` 最小可用
- 目标：对一批本地文档实现检索问答与引用
- 学：`文档切分`、`嵌入` 与 `向量库`、`BM25+向量混合检索`、`重排器（Reranker）`、`引用` 与 `去幻觉`
- 练：选一套文档（`Markdown`/`知识库`），实现问答；返回引用段落与 `URL`

## 第 3 周：`工具调用` 与 `MCP`
- 目标：模型能查实时信息或企业系统
- 学：`OpenAI/Anthropic/Qwen` 的 `工具调用`；`MCP` 基本概念与示例服务器
- 练：做 2 个工具
  - `HTTP 工具`：天气或汇率查询
  - `业务工具`：工单系统（`mock`）查询/创建
- 加分：把工单工具封成 `MCP 服务器`；在模型侧自动发现并调用

## 第 4 周：`Context Engine` 雏形
- 目标：学会“给模型喂对的信息且不超上下文”
- 学：`意图路由（routing）`（`RAG` vs `工具`）、`token 预算`、`压缩（摘要/回填）`
- 练：实现一个路由器
  - 若问“是什么/怎么做”类 => `RAG`
  - 若问“查询/下单/创建/时间”类 => `工具`
  - `历史消息压缩`：只保留与当前问题强相关的摘要
  - `缓存（cache）`：对稳定的 `system prompt` 或长背景用提示缓存

## 第 5 周：引入 `Agent` 编排
- 目标：让模型能多步完成任务并知道何时停止
- 学：`LangGraph`/`LangChain` 的有向图编排；`中间状态` 与 `错误恢复`；`停止条件`
- 练：实现一个小图  
  - `route -> (RAG 或 工具) -> 汇总 -> 若缺信息再检索/再调用 -> 结束`
  - 输出包括：`最终答复 + 引用 + 执行动作列表`

## 第 6 周：`评测`、`观察` 与 `上线`
- 目标：稳定可演示，能解释效果，能优化
- 学：`RAG 评测`（`正确率/支持性/覆盖率`）、`提示回归测试`、`成本` 与 `时延监控`
- 练：做一个最小评测集（20–50 条），跑离线评测；接入 `日志`；做 `速率限制` 与 `API Key 管理`

# 四、`Demo` 方案（`知识库问答` + `工单工具`）
- 功能目标
  - 用户能就 `产品 FAQ` 提问（`RAG`），并返回`引用`
  - 用户能 `查询工单状态`、`创建工单`（`工具/MCP`）
  - 复杂请求时，`Agent` 选择合适步骤完成任务
  - 所有输出尽量 `结构化`，保证`可追溯`
- 技术栈建议
  - 语言：`Python`
  - 模型：`OpenAI`（如 `o4/o3` 或 `GPT-4o-mini`）、`Anthropic Claude 3.5`、性价比：`DeepSeek`/`Qwen`
  - 向量库：开发用 `Chroma` 或 `Qdrant`；生产可 `pgvector`/`Weaviate`/`Milvus`
  - 框架：`LangChain/LangGraph` 或 `LlamaIndex`
  - Web/API：`FastAPI` 后端 + `Streamlit`/`Next.js` 前端
  - 观测/评测：`Langfuse`/`TruLens`/`RAGAS`
- 数据与索引
  - 采集：导出 `FAQ/Wiki` 为 `Markdown` 或 `HTML`
  - 清洗：去`广告/导航`、保留`标题层级`
  - 切分：按`标题+语义`切分（`200–500 tokens`），保留`元数据（title/url/anchor）`
  - 嵌入：中文首选 `bge-m3`、`jina-embeddings-v3`；通用可 `text-embedding-3-large`
  - 检索：`向量 + BM25` 混合；`top-k 8–12`；可加 `重排（bge-reranker）`
- 工具与 `MCP`
  - 工具 A：`get_ticket(id)` / `create_ticket(subject, desc, priority)`（可用内存数组模拟）
  - 工具 B：`get_status()`（系统健康/版本）
  - 封装方式
    - 直接 `工具调用`（`OpenAI/Anthropic` 的 `tools/functions`）
    - 或暴露为 `MCP 服务器` 给模型发现（进阶）
- `Context Engine` 逻辑（伪代码）
  ```python
  def context_engine(user_q, history):
      Hc = compress(history)              # 历史压缩
      intent = classify(user_q)           # 意图识别

      ctx = []
      tool_plan = None

      if intent in ["faq", "how-to", "definition"]:
          docs = retrieve(user_q)         # RAG
          ctx = rank_and_compact(docs, budget=4000)  # 排序压缩
      elif intent in ["query_ticket", "create_ticket", "status"]:
          tool_plan = build_tool_plan(user_q)        # 工具计划

      messages = assemble_prompt(
          system_prompt=BASE_SYSTEM_PROMPT,
          history=Hc,
          context=ctx,
          tool_schemas=AVAILABLE_TOOLS
      )
      return messages, tool_plan
  ```
- `Agent` 流程（图式）
  - `start -> route`
    - if `RAG`: `retrieve -> synthesize -> enough? -> finalize(with citations)` | else `refine -> retrieve`
    - if `TOOL`: `decide tool -> call -> observe -> need more? -> ask user -> finalize`
  - 结束条件：`置信度足够`或`用户确认完成`
  - 产出：`answer`、`citations`、`actions_log`

- 最小接口与验收
  - 后端提供两个 `HTTP` 端点
    - `POST /chat`：输入 `session_id`、用户消息；返回 `answer`、`citations`、`actions_log`
    - `POST /ingest`：上传/刷新文档；后台重建索引
  - `Demo` 验收脚本
    - “这个产品如何重置密码？”（走 `RAG` 并附 `引用`）
    - “帮我创建一个高优先级工单，标题 X，内容 Y”（走 `工具创建`，返回 `ticket_id`）
    - “查询刚才工单状态”（走 `工具查询`）
    - “综合上面工单与文档给个解决建议”（`RAG + 工具结果融合`）

# 五、做或不做的决策指南
- 先 `RAG` 后 `微调`：99% 知识型问题先用 `RAG`；`微调`用于风格/结构固化或特定能力补齐
- 何时上 `Agent`：当需要`多步`、`条件分支`、`工具选择与重试`时；否则先保守用“单轮 + 工具”
- 是否用 `MCP`：若 `工具/数据源` 较多且想标准化对接与“自发现”，上；否则先用直连 `函数调用`
- `Context Engine` 不等于框架：是应用里的`上下文编排策略`，可用现成组件实现

# 六、评测与可观测的最小闭环
- `RAG`：基于问答对做`支持性/真实性/引用命中率`；工具：`RAGAS` 或自写脚本
- `工具`：`单元测试` + `回归集`（覆盖`正常/缺参/失败/超时`）
- `成本与延迟`：记录每轮 `tokens`、调用次数、平均延迟；设`预算与报警`
- `质量运营`：抽样`人工评审`；收集用户“有用/无用”反馈用于改进`检索`与`提示`

# 七、常见坑与避坑术
- `上下文爆炸`：强制 `token 预算`；历史做`摘要`；检索结果做`压缩与去重`
- `RAG 无关文档混入`：`混合检索+重排`；`chunk` 带`标题与路径`；召回不过多不过少
- `幻觉` 与 `瞎编工具参数`：用 `JSON Schema` 严格校验；对关键操作加`用户确认`
- `工具失败`：设置`重试、超时`与`回退回答`；在答案里透明披露失败原因
- `多模型供应商`：抽象出 `model client` 接口，便于`切换`与`A/B`
- `数据合规`：`隐私脱敏`，`权限检查`（尤其 `MCP/工具层`）

# 八、参考与选型建议
- 编排与 `RAG`：`LangChain/LangGraph` 或 `LlamaIndex`（二选一深入）
- 向量库：开发阶段 `Chroma/Qdrant`；生产优先 `pgvector（Postgres）`
- 评测：`RAGAS`、`Langfuse`、`TruLens`
- 嵌入模型：中文优先 `bge-m3`、`jina-embeddings-v3`；通用可 `text-embedding-3-large`
- 文档清洗：`trafilatura`/`readability`；`PDF` 用 `PyMuPDF`
- 前端：`Streamlit`（快）或 `Next.js`（美观）

如果你愿意，我可以把上述 `Demo` 进一步具体化为项目`仓库结构`、`依赖清单`与`关键模块代码骨架`（如 `FastAPI + LangGraph` 的最小实现），并附上一份 `1–2 天`内可完成的`任务清单`。